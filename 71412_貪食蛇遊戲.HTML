HTML
<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>è²ªé£Ÿè›‡éŠæˆ² - ä¿®æ­£ç‰ˆ</title>
    <style>
        /* CSS æ¨£å¼ */
        body { 
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f7f7f7;
            color: #333;
            padding: 20px;
        }

        h1 {
            color: #4CAF50;
        }

        #game-board { 
            /* ä¿®æ­£: ç¢ºä¿å–®å…ƒæ ¼ä½ˆå±€å’Œé‚Šæ¡†æ­£ç¢º */
            border: 5px solid #333; 
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
            display: grid; 
            background-color: #d1d1d1; 
            margin: 10px 0;
        }

        .cell { 
            border: 1px solid #c0c0c0; 
            box-sizing: border-box; 
        }

        .snake { 
            background-color: #1a7f37;
            border-radius: 2px; 
        }

        .food { 
            background-color: #FF5733; 
            border-radius: 50%; 
            border: 1px solid #cc4422;
        }

        #score-board { 
            margin-bottom: 20px; 
            font-size: 1.8em; 
            font-weight: bold;
            background-color: #fff;
            padding: 10px 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        /* éŠæˆ²çµæŸç•«é¢æ¨£å¼ */
        #game-over-screen {
            display: none; 
            position: fixed; 
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            background-color: rgba(0, 0, 0, 0.9);
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #game-over-content {
            padding: 40px;
            background-color: #333;
            border-radius: 15px;
            text-align: center;
            box-shadow: 0 0 40px rgba(255, 255, 255, 0.3);
            min-width: 300px;
        }

        #game-over-content h2 {
            color: #FFC300;
            margin-top: 0;
        }
        
        #game-over-screen button {
            padding: 12px 25px;
            margin-top: 20px;
            font-size: 1.1em;
            cursor: pointer;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 8px;
            transition: background-color 0.3s;
        }

        #game-over-screen button:hover {
            background-color: #45a049;
        }
    </style>
</head>
<body>
    <h1>ğŸ è²ªé£Ÿè›‡éŠæˆ² ğŸ</h1>
    <div id="score-board">å¾—åˆ†: <span id="score">0</span></div>
    <div id="game-board">
        </div>

    <div id="game-over-screen">
        <div id="game-over-content">
            <h2>éŠæˆ²çµæŸï¼</h2>
            <p>ä½ çš„æœ€çµ‚å¾—åˆ†æ˜¯: <span id="final-score">0</span></p>
            <p style="font-size: 0.9em;">ä½¿ç”¨æ–¹å‘éµ (â†‘ â†“ â† â†’) æˆ– WASD éµæ§åˆ¶</p>
            <button onclick="startGame()">å†ç©ä¸€æ¬¡</button>
        </div>
    </div>

    <script>
        // JavaScript é‚è¼¯
        
        // éŠæˆ²åƒæ•¸
        const GRID_SIZE = 20; // ç¶²æ ¼å¤§å° (20x20)
        const CELL_SIZE = 20; // æ¯å€‹å–®å…ƒæ ¼çš„åƒç´ å¤§å°
        const INITIAL_SPEED = 150; // åˆå§‹éŠæˆ²é€Ÿåº¦ (æ¯«ç§’)

        // DOM å…ƒç´ 
        const gameBoard = document.getElementById('game-board');
        const scoreDisplay = document.getElementById('score');
        const gameOverScreen = document.getElementById('game-over-screen');
        const finalScoreDisplay = document.getElementById('final-score');

        // éŠæˆ²ç‹€æ…‹è®Šæ•¸
        let snake = [{ x: 10, y: 10 }];
        let food = {};
        let direction = 'right'; 
        let nextDirection = 'right'; // è™•ç†å¿«é€ŸæŒ‰éµè¼¸å…¥
        let score = 0;
        let gameLoopInterval;
        let isGameOver = true; // åˆå§‹ç‹€æ…‹è¨­ç‚ºçµæŸï¼Œç­‰å¾… startGame() å•Ÿå‹•

        // è¨­ç½®ç¶²æ ¼å¤§å°å’Œæ¨£å¼
        gameBoard.style.gridTemplateColumns = `repeat(${GRID_SIZE}, ${CELL_SIZE}px)`;
        gameBoard.style.gridTemplateRows = `repeat(${GRID_SIZE}, ${CELL_SIZE}px)`;
        gameBoard.style.width = `${GRID_SIZE * CELL_SIZE}px`;
        gameBoard.style.height = `${GRID_SIZE * CELL_SIZE}px`;


        // 1. åˆå§‹åŒ–éŠæˆ²ç¶²æ ¼
        function createGrid() {
            gameBoard.innerHTML = '';
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.id = `cell-${x}-${y}`;
                    gameBoard.appendChild(cell);
                }
            }
        }

        // 2. éš¨æ©Ÿç”Ÿæˆé£Ÿç‰©ä½ç½®
        function generateFood() {
            let newFood;
            do {
                newFood = {
                    x: Math.floor(Math.random() * GRID_SIZE),
                    y: Math.floor(Math.random() * GRID_SIZE)
                };
            } while (snake.some(segment => segment.x === newFood.x && segment.y === newFood.y)); 
            food = newFood;
        }

        // 3. ç¹ªè£½éŠæˆ²ç‹€æ…‹
        function draw() {
            // å„ªåŒ–: åªç§»é™¤ç›¸é—œé¡åˆ¥ï¼Œé¿å…é‡ç¹ªæ‰€æœ‰å–®å…ƒæ ¼
            document.querySelectorAll('.snake, .food').forEach(el => {
                el.classList.remove('snake', 'food');
            });

            // ç¹ªè£½è›‡
            snake.forEach(segment => {
                const cell = document.getElementById(`cell-${segment.x}-${segment.y}`);
                if (cell) {
                    cell.classList.add('snake');
                }
            });

            // ç¹ªè£½é£Ÿç‰©
            const foodCell = document.getElementById(`cell-${food.x}-${food.y}`);
            if (foodCell) {
                foodCell.classList.add('food');
            }

            // æ›´æ–°åˆ†æ•¸
            scoreDisplay.textContent = score;
        }

        // 4. éŠæˆ²ä¸»å¾ªç’° (ç§»å‹•å’Œæª¢æŸ¥)
        function gameLoop() {
            if (isGameOver) return; // ç¢ºä¿éŠæˆ²çµæŸæ™‚å¾ªç’°åœæ­¢é‹è¡Œ

            // ä¿®æ­£: åœ¨ç§»å‹•å‰æ›´æ–°æ–¹å‘
            direction = nextDirection; 

            // ç²å–è›‡é ­çš„æ–°ä½ç½®
            const head = { ...snake[0] };
            switch (direction) {
                case 'up': head.y--; break;
                case 'down': head.y++; break;
                case 'left': head.x--; break;
                case 'right': head.x++; break;
            }

            // æª¢æŸ¥ç¢°æ’
            const wallCollision = head.x < 0 || head.x >= GRID_SIZE || head.y < 0 || head.y >= GRID_SIZE;
            
            // ä¿®æ­£: è‡ªæ’æª¢æŸ¥ (å¾ç¬¬äºŒå€‹ç‰‡æ®µé–‹å§‹æª¢æŸ¥)
            const selfCollision = snake.some((segment, index) => index > 0 && segment.x === head.x && segment.y === head.y);

            if (wallCollision || selfCollision) {
                clearInterval(gameLoopInterval);
                showGameOver();
                return;
            }

            // å°‡æ–°é ­éƒ¨æ·»åŠ åˆ°è›‡èº«
            snake.unshift(head);

            // æª¢æŸ¥æ˜¯å¦åƒåˆ°é£Ÿç‰©
            if (head.x === food.x && head.y === food.y) {
                score += 10;
                generateFood();
                
                // éŠæˆ²åŠ é€Ÿé‚è¼¯
                const newSpeed = INITIAL_SPEED - (score * 0.5); // åŠ é€Ÿä¿‚æ•¸ç•¥å¾®èª¿ä½
                const actualSpeed = Math.max(newSpeed, 70); 

                clearInterval(gameLoopInterval);
                gameLoopInterval = setInterval(gameLoop, actualSpeed);

            } else {
                snake.pop(); // ç§»é™¤å°¾å·´
            }

            draw();
        }

        // 5. è™•ç†éµç›¤è¼¸å…¥
        document.addEventListener('keydown', e => {
            if (isGameOver && (e.key === 'ArrowUp' || e.key === 'w' || e.key === ' ' || e.key === 'Enter')) {
                // å¦‚æœéŠæˆ²çµæŸï¼ŒæŒ‰ä¸‹ä»»æ„æ§åˆ¶éµæˆ–ç©ºç™½éµ/Enterï¼Œå‰‡é‡æ–°é–‹å§‹
                startGame();
                return;
            }

            // ç¢ºä¿ç©å®¶ä¸èƒ½ç«‹åˆ»åå‘ç§»å‹•
            switch (e.key) {
                case 'ArrowUp':
                case 'w':
                    if (direction !== 'down') nextDirection = 'up';
                    break;
                case 'ArrowDown':
                case 's':
                    if (direction !== 'up') nextDirection = 'down';
                    break;
                case 'ArrowLeft':
                case 'a':
                    if (direction !== 'right') nextDirection = 'left';
                    break;
                case 'ArrowRight':
                case 'd':
                    if (direction !== 'left') nextDirection = 'right';
                    break;
            }
        });

        // 6. é¡¯ç¤ºéŠæˆ²çµæŸç•«é¢
        function showGameOver() {
            isGameOver = true;
            finalScoreDisplay.textContent = score;
            gameOverScreen.style.display = 'flex'; 
        }

        // 7. é–‹å§‹/é‡å•ŸéŠæˆ²
        function startGame() {
            // é‡è¨­ç‹€æ…‹
            snake = [{ x: 10, y: 10 }];
            direction = 'right';
            nextDirection = 'right';
            score = 0;
            isGameOver = false;

            gameOverScreen.style.display = 'none';

            createGrid();
            generateFood();

            if (gameLoopInterval) clearInterval(gameLoopInterval);
            gameLoopInterval = setInterval(gameLoop, INITIAL_SPEED);

            draw();
        }

        // åˆå§‹è¼‰å…¥æ™‚é¡¯ç¤ºçµæŸç•«é¢ï¼Œæç¤ºç”¨æˆ¶æŒ‰éˆ•é–‹å§‹
        showGameOver();
        finalScoreDisplay.textContent = 0; // è®“åˆå§‹åˆ†æ•¸é¡¯ç¤ºç‚º0
        
    </script>
</body>
</html>

